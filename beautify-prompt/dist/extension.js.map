{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://beautify-prompt/./src/extension.ts","webpack://beautify-prompt/external commonjs \"vscode\"","webpack://beautify-prompt/webpack/bootstrap","webpack://beautify-prompt/webpack/startup"],"sourcesContent":["// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\n\n// This method is called when your extension is activated\n// Your extension is activated the very first time the command is executed\n// Create a dedicated output channel for debugging\nconst outputChannel = vscode.window.createOutputChannel('Beautify Prompt');\n\n// Helper function for logging\nfunction logDebug(message: string, ...data: any[]): void {\n\tconst timestamp = new Date().toISOString();\n\toutputChannel.appendLine(`[${timestamp}] ${message}`);\n\tif (data && data.length > 0) {\n\t\toutputChannel.appendLine(JSON.stringify(data, null, 2));\n\t}\n}\n\nexport function activate(context: vscode.ExtensionContext) {\n\t// Use the output channel for debugging\n\tlogDebug('Extension \"beautify-prompt\" is now active');\n\t\n\t// Create status bar item for the @bp agent\n\tconst bpAgentStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);\n\tbpAgentStatusBarItem.text = \"$(sparkle) @bp\";\n\tbpAgentStatusBarItem.tooltip = \"Beautify Prompt Agent (@bp) - Click to beautify prompt\";\n\tbpAgentStatusBarItem.command = 'beautify-prompt.bpAgentBeautify';\n\tcontext.subscriptions.push(bpAgentStatusBarItem);\n\n\t// Register the beautifyPrompt command for editor text\n\tconst beautifyEditorPrompt = vscode.commands.registerCommand('beautify-prompt.beautifyPrompt', async () => {\n\t\tawait handleEditorPromptBeautification();\n\t});\n\n\t// Register the beautifyChatPrompt command for Copilot Chat\n\tconst beautifyChatPrompt = vscode.commands.registerCommand('beautify-prompt.beautifyChatPrompt', async () => {\n\t\tawait handleChatPromptBeautification();\n\t});\n\t\n\t// Register the command to check for and auto-beautify prompts with the prefix\n\tconst autoBeautifyPrompt = vscode.commands.registerCommand('beautify-prompt.checkAutoBeautify', async () => {\n\t\tawait checkClipboardForAutoBeautify();\n\t});\n\n\t// Register a specific command for @bp agent beautification\n\tconst bpAgentBeautify = vscode.commands.registerCommand('beautify-prompt.bpAgentBeautify', async () => {\n\t\tawait handleBpAgentBeautification();\n\t});\n\t\n\t// Register command to generate a sample custom template\n\tconst generateTemplateCommand = vscode.commands.registerCommand('beautify-prompt.generateTemplateFile', async () => {\n\t\tawait generateCustomTemplateFile();\n\t});\n\n\t// Set up a timer to periodically check clipboard for @bp agent commands\n\tconst clipboardCheckInterval = setInterval(async () => {\n\t\tawait checkClipboardForBpAgent(bpAgentStatusBarItem);\n\t}, 1000); // Check every second\n\n\t// Make sure to clear interval when extension is deactivated\n\tcontext.subscriptions.push({ dispose: () => clearInterval(clipboardCheckInterval) });\n\t\n\tcontext.subscriptions.push(beautifyEditorPrompt);\n\tcontext.subscriptions.push(beautifyChatPrompt);\n\tcontext.subscriptions.push(autoBeautifyPrompt);\n\tcontext.subscriptions.push(bpAgentBeautify);\n\tcontext.subscriptions.push(generateTemplateCommand);\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}\n\n/**\n * Handles the beautification of prompts in the editor\n */\nasync function handleEditorPromptBeautification(): Promise<void> {\n\tconst editor = vscode.window.activeTextEditor;\n\t\n\tif (!editor) {\n\t\tvscode.window.showInformationMessage('No editor is active');\n\t\treturn;\n\t}\n\n\t// Get the selected text\n\tconst selection = editor.selection;\n\tif (selection.isEmpty) {\n\t\tvscode.window.showInformationMessage('Please select text to beautify');\n\t\treturn;\n\t}\n\t\n\tconst originalPrompt = editor.document.getText(selection);\n\t\n\t// Check if the prompt has the auto-beautify prefix\n\tconst { hasPrefix, processedPrompt } = checkAndProcessAutoBeautifyPrefix(originalPrompt);\n\t\n\ttry {\n\t\t// Show a progress notification\n\t\tconst enhancedPrompt = await vscode.window.withProgress({\n\t\t\tlocation: vscode.ProgressLocation.Notification,\n\t\t\ttitle: \"Beautify prompt...\",\n\t\t\tcancellable: false\n\t\t}, async (progress) => {\n\t\t\t// Call our prompt beautifier function\n\t\t\treturn await beautifyPromptText(processedPrompt);\n\t\t});\n\t\t\n\t\t// Replace the selected text with the beautified prompt\n\t\teditor.edit(editBuilder => {\n\t\t\teditBuilder.replace(selection, enhancedPrompt);\n\t\t});\n\t\t\n\t\tvscode.window.showInformationMessage('Prompt beautified successfully!');\n\t} catch (error) {\n\t\tvscode.window.showErrorMessage(`Failed to beautify prompt: ${error instanceof Error ? error.message : String(error)}`);\n\t}\n}\n\n/**\n * Handles the beautification of prompts in GitHub Copilot Chat\n */\nasync function handleChatPromptBeautification(): Promise<void> {\n\t// Try to find the Copilot Chat input box\n\t// Note: Since there's no public API for Copilot Chat yet, we'll use clipboard as an intermediate\n\t\n\t// Simulate the keyboard shortcut sequence to select all text in the chat input\n\tawait vscode.commands.executeCommand('editor.action.clipboardCopyWithSyntaxHighlightingAction');\n\t\n\t// Get the clipboard content\n\tconst clipboardText = await vscode.env.clipboard.readText();\n\t\n\tif (!clipboardText || clipboardText.trim() === '') {\n\t\tvscode.window.showInformationMessage('No text found in the Copilot Chat input');\n\t\treturn;\n\t}\n\t\n\t// Check if the prompt has the auto-beautify prefix\n\tconst { hasPrefix, processedPrompt } = checkAndProcessAutoBeautifyPrefix(clipboardText);\n\t\n\ttry {\n\t\t// Show a progress notification\n\t\tconst enhancedPrompt = await vscode.window.withProgress({\n\t\t\tlocation: vscode.ProgressLocation.Notification,\n\t\t\ttitle: \"Beautify Copilot Chat prompt...\",\n\t\t\tcancellable: false\n\t\t}, async (progress) => {\n\t\t\t// Call our prompt beautifier function\n\t\t\treturn await beautifyPromptText(processedPrompt);\n\t\t});\n\t\t\n\t\t// Write the beautified prompt back to clipboard\n\t\tawait vscode.env.clipboard.writeText(enhancedPrompt);\n\t\t\n\t\t// Show instructions for pasting\n\t\tvscode.window.showInformationMessage('Prompt beautified! Press Ctrl+V/Cmd+V to paste it into the chat input.');\n\t} catch (error) {\n\t\tvscode.window.showErrorMessage(`Failed to beautify prompt: ${error instanceof Error ? error.message : String(error)}`);\n\t}\n}\n\n/**\n * Reads a custom prompt template from a file if it exists\n * @returns The custom prompt template or null if not found\n */\nasync function readCustomPromptTemplate(): Promise<string | null> {\n\ttry {\n\t\t// Get all workspace folders\n\t\tconst workspaceFolders = vscode.workspace.workspaceFolders;\n\t\tif (!workspaceFolders || workspaceFolders.length === 0) {\n\t\t\tlogDebug('No workspace folders found');\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check each workspace folder for the .github/bp_actionA.md file\n\t\tfor (const folder of workspaceFolders) {\n\t\t\tconst customPromptPath = vscode.Uri.joinPath(folder.uri, '.github', 'bp_actionA.md');\n\t\t\t\n\t\t\ttry {\n\t\t\t\t// Try to read the file\n\t\t\t\tlogDebug(`Attempting to read custom prompt from: ${customPromptPath.fsPath}`);\n\t\t\t\tconst fileContent = await vscode.workspace.fs.readFile(customPromptPath);\n\t\t\t\tconst templateText = Buffer.from(fileContent).toString('utf8');\n\t\t\t\t\n\t\t\t\tlogDebug('Custom prompt template found', templateText.substring(0, 100) + '...');\n\t\t\t\treturn templateText;\n\t\t\t} catch (err) {\n\t\t\t\t// File doesn't exist in this workspace folder, continue to next one\n\t\t\t\tlogDebug(`Custom prompt not found in ${folder.name}: ${err instanceof Error ? err.message : String(err)}`);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// No custom prompt found in any workspace folder\n\t\tlogDebug('No custom prompt template found in any workspace folder');\n\t\treturn null;\n\t} catch (error) {\n\t\tlogDebug('Error while reading custom prompt template', error);\n\t\treturn null;\n\t}\n}\n\n/**\n * Beautifies a GitHub Copilot prompt to make it more effective\n * @param originalPrompt The original user prompt text\n * @returns Beautified prompt text\n */\nasync function beautifyPromptText(originalPrompt: string): Promise<string> {\n\t// Try to read custom prompt template first\n\tconst customTemplate = await readCustomPromptTemplate();\n\t\n\tlet beautifiedPromptRequest: string;\n\t\n\tif (customTemplate) {\n\t\t// Use the custom template if available\n\t\tlogDebug('Using custom prompt template from .github/bp_actionA.md');\n\t\t// Replace placeholder with the actual prompt text\n\t\tbeautifiedPromptRequest = customTemplate.replace('{{PROMPT}}', originalPrompt);\n\t} else {\n\t\t// Fall back to the default built-in prompt if no custom template is found\n\t\tlogDebug('Using default built-in prompt template');\n\t\t// Creating a beautified version of the prompt with default template\n\t\tconst promptParts = [\n\t\t\t// Start with a clear definition of what we're beautifying\n\t\t\t\"I need to improve this prompt for GitHub Copilot to generate better code in a software development context:\",\n\t\t\t`Original prompt: \"${originalPrompt}\"`,\n\t\t\t\n\t\t\t// Add beautifier instructions specific to software development\n\t\t\t\"Please beautify this prompt for optimal code generation by:\",\n\t\t\t\"1. Making it more specific and clearer with precise programming terminology\",\n\t\t\t\"2. Adding necessary technical context (language, framework, libraries, versions)\",\n\t\t\t\"3. Indicating expected output format (function signature, class structure, code style)\",\n\t\t\t\"4. Breaking it into logical development steps or components\",\n\t\t\t\"5. Specifying error handling, edge cases, and performance considerations\",\n\t\t\t\"6. Including any necessary imports, dependencies, or setup requirements\",\n\t\t\t\"7. Mentioning testing expectations if applicable\",\n\t\t\t\"8. Providing clarity on design patterns or architectural approaches\",\n\t\t\t\"9. Defining variable naming conventions or code style preferences\",\n\t\t\t\n\t\t\t// Request format\n\t\t\t\"Return only the beautified prompt text without explanations or additional text. Focus exclusively on software development context.\"\n\t\t];\n\t\t\n\t\t// Construct prompt for language model\n\t\tbeautifiedPromptRequest = promptParts.join(\"\\n\\n\");\n\t}\n\t\n\ttry {\n\t\t// Here we would ideally call the GitHub Copilot API directly\n\t\t// Since there's no direct API for prompt beautification, we're implementing a local beautifier\n\t\t\n\t\t// For now, we'll implement a simple beautification logic\n\t\t// In a production extension, you might want to use a proper AI service API\n\t\t\n\t\tconst beautifiedPrompt = await simulateCopilotBeautification(beautifiedPromptRequest);\n\t\treturn beautifiedPrompt;\n\t} catch (error) {\n\t\tconsole.error('Error beautifying prompt:', error);\n\t\tthrow new Error('Failed to beautify prompt. Please try again.');\n\t}\n}\n\n/**\n * Simulates GitHub Copilot's prompt beautification\n * In a real extension, this could be replaced with a call to an actual API\n */\nasync function simulateCopilotBeautification(originalPrompt: string): Promise<string> {\n\t// Software development-specific enhancements\n\tconst improvedPrompt = originalPrompt.trim();\n\t\n\t// Add task structure if not present\n\tlet enhancedPrompt = improvedPrompt;\n\t\n\tif (!improvedPrompt.includes('Task:') && !improvedPrompt.includes('Goal:')) {\n\t\tenhancedPrompt = `Task: ${improvedPrompt}`;\n\t}\n\t\n\t// Add technical context section if missing\n\tif (!improvedPrompt.includes('Context:') && !improvedPrompt.includes('Technology:')) {\n\t\tenhancedPrompt += '\\n\\nContext: Using the latest version of JavaScript/TypeScript with modern ES features.';\n\t}\n\t\n\t// Add language/framework specific details if not mentioned\n\tif (!improvedPrompt.toLowerCase().includes('javascript') && \n\t\t!improvedPrompt.toLowerCase().includes('typescript') && \n\t\t!improvedPrompt.toLowerCase().includes('python') && \n\t\t!improvedPrompt.toLowerCase().includes('java') && \n\t\t!improvedPrompt.toLowerCase().includes('c#')) {\n\t\tenhancedPrompt += '\\n\\nLanguage: Implement this in TypeScript with strict type checking.';\n\t}\n\t\n\t// Add expected output format if missing\n\tif (!improvedPrompt.includes('Expected output:') && \n\t\t!improvedPrompt.includes('Return:') &&\n\t\t!improvedPrompt.includes('Output:')) {\n\t\tenhancedPrompt += '\\n\\nExpected output: Well-structured, documented code with proper types and error handling.';\n\t}\n\t\n\t// Add requirements section if not present\n\tif (!improvedPrompt.includes('Requirements:')) {\n\t\tenhancedPrompt += '\\n\\nRequirements:';\n\t\tenhancedPrompt += '\\n1. Code should be maintainable and follow SOLID principles';\n\t\tenhancedPrompt += '\\n2. Include proper error handling for edge cases';\n\t\tenhancedPrompt += '\\n3. Optimize for performance where applicable';\n\t\tenhancedPrompt += '\\n4. Add comprehensive documentation';\n\t}\n\t\n\t// Add testing expectations if not mentioned\n\tif (!improvedPrompt.includes('Testing:') && !improvedPrompt.includes('tests')) {\n\t\tenhancedPrompt += '\\n\\nTesting: Include examples of how to test the code.';\n\t}\n\t\n\t// Add specificity if the prompt is very short\n\tif (improvedPrompt.split(' ').length < 5) {\n\t\tenhancedPrompt += '\\n\\nPlease provide a comprehensive solution with proper architecture, error handling, and documentation comments.';\n\t}\n\t\n\t// Simulate API call delay\n\tawait new Promise(resolve => setTimeout(resolve, 1000));\n\t\n\treturn enhancedPrompt;\n}\n\n/**\n * Checks if a prompt starts with the auto-beautify prefix and processes it accordingly\n * @param promptText The original prompt text\n * @returns Object containing whether the prefix was found and the processed prompt\n */\nfunction checkAndProcessAutoBeautifyPrefix(promptText: string): { hasPrefix: boolean; processedPrompt: string } {\n\t// Get the configuration\n\tconst config = vscode.workspace.getConfiguration('beautify-prompt');\n\tconst enableAutoBeautify = config.get<boolean>('enableAutoBeautify', true);\n\tconst autoBeautifyPrefix = config.get<string>('autoBeautifyPrefix', 'beautify prompt:').toLowerCase();\n\t\n\t// If auto-beautify is disabled, return the original prompt\n\tif (!enableAutoBeautify) {\n\t\treturn { hasPrefix: false, processedPrompt: promptText };\n\t}\n\t\n\t// Check if the prompt starts with the prefix (case insensitive)\n\tconst lowerCasePrompt = promptText.toLowerCase();\n\t\n\t// Check for the standard prefix\n\tif (lowerCasePrompt.startsWith(autoBeautifyPrefix)) {\n\t\t// Remove the prefix from the prompt (use the original case)\n\t\tconst processedPrompt = promptText.substring(autoBeautifyPrefix.length).trim();\n\t\treturn { hasPrefix: true, processedPrompt };\n\t}\n\t\n\t// Check for the @bp agent prefix\n\tconst bpAgentPrefix = '@bp';\n\tif (lowerCasePrompt.startsWith(bpAgentPrefix)) {\n\t\t// Remove the @bp prefix from the prompt\n\t\tconst processedPrompt = promptText.substring(bpAgentPrefix.length).trim();\n\t\treturn { hasPrefix: true, processedPrompt };\n\t}\n\t\n\t// Return the original prompt if no prefix is found\n\treturn { hasPrefix: false, processedPrompt: promptText };\n}\n\n/**\n * Checks the clipboard content for the auto-beautify prefix and beautifies it if found\n * This can be used to auto-beautify prompts as they're being typed\n */\nasync function checkClipboardForAutoBeautify(): Promise<void> {\n\t// Get the clipboard content\n\tconst clipboardText = await vscode.env.clipboard.readText();\n\t\n\tif (!clipboardText || clipboardText.trim() === '') {\n\t\treturn;\n\t}\n\t\n\t// Check if the prompt has the auto-beautify prefix\n\tconst { hasPrefix, processedPrompt } = checkAndProcessAutoBeautifyPrefix(clipboardText);\n\t\n\t// Only proceed if the prefix is found\n\tif (hasPrefix) {\n\t\ttry {\n\t\t\t// Beautify the prompt\n\t\t\tconst enhancedPrompt = await beautifyPromptText(processedPrompt);\n\t\t\t\n\t\t\t// Write the beautified prompt back to clipboard\n\t\t\tawait vscode.env.clipboard.writeText(enhancedPrompt);\n\t\t\t\n\t\t\t// Show a subtle notification\n\t\t\tvscode.window.showInformationMessage('Auto-beautified prompt!', { modal: false });\n\t\t} catch (error) {\n\t\t\tconsole.error('Error during auto-beautification:', error);\n\t\t}\n\t}\n}\n\n/**\n * Checks the clipboard content specifically for the @bp agent command\n * Shows/hides the status bar item accordingly\n */\n// Keep track of the last clipboard text to avoid excessive logging\nlet lastClipboardText = '';\n\nasync function checkClipboardForBpAgent(statusBarItem: vscode.StatusBarItem): Promise<void> {\n\t// Get the clipboard content\n\tconst clipboardText = await vscode.env.clipboard.readText();\n\t\n\t// For debugging, log only when there's a change (to avoid console spam)\n\tif (clipboardText !== lastClipboardText) {\n\t\tlogDebug('BP Agent monitor: Clipboard changed', \n\t\t\tclipboardText ? clipboardText.substring(0, 20) + '...' : 'empty');\n\t\tlastClipboardText = clipboardText;\n\t}\n\t\n\tif (!clipboardText || clipboardText.trim() === '') {\n\t\tstatusBarItem.hide();\n\t\treturn;\n\t}\n\t\n\t// Specifically check for the @bp agent prefix at the beginning of the input\n\tconst lowerCasePrompt = clipboardText.toLowerCase().trim();\n\tconst bpAgentPrefix = '@bp';\n\t\n\tif (lowerCasePrompt.startsWith(bpAgentPrefix)) {\n\t\t// Show the status bar item when @bp is detected\n\t\tlogDebug('BP Agent monitor: @bp detected, showing status bar item');\n\t\tstatusBarItem.show();\n\t} else {\n\t\t// Hide it otherwise\n\t\tstatusBarItem.hide();\n\t}\n}\n\n/**\n * Handles the beautification triggered by the @bp agent command\n * Provides a more agent-like experience with specific feedback\n */\nasync function handleBpAgentBeautification(): Promise<void> {\n\t// Get the clipboard content\n\tconst clipboardText = await vscode.env.clipboard.readText();\n\t\n\tlogDebug('BP Agent: Clipboard text retrieved', clipboardText ? clipboardText.substring(0, 30) + '...' : 'empty');\n\t\n\tif (!clipboardText || clipboardText.trim() === '') {\n\t\tvscode.window.showInformationMessage('@bp agent: No text found to beautify');\n\t\treturn;\n\t}\n\t\n\t// Check specifically for the @bp prefix\n\tconst lowerCasePrompt = clipboardText.toLowerCase().trim();\n\tconst bpAgentPrefix = '@bp';\n\t\n\tlogDebug('BP Agent: Checking for prefix', { lowerCasePrompt, startsWith: lowerCasePrompt.startsWith(bpAgentPrefix) });\n\t\n\tif (lowerCasePrompt.startsWith(bpAgentPrefix)) {\n\t\ttry {\n\t\t\t// Remove the @bp prefix\n\t\t\tconst processedPrompt = clipboardText.substring(bpAgentPrefix.length).trim();\n\t\t\tconsole.log('BP Agent debug: Processed prompt', processedPrompt);\n\t\t\t\n\t\t\t// Show a progress notification with @bp agent branding\n\t\t\tconst enhancedPrompt = await vscode.window.withProgress({\n\t\t\t\tlocation: vscode.ProgressLocation.Notification,\n\t\t\t\ttitle: \"@bp agent: Beautifying prompt...\",\n\t\t\t\tcancellable: false\n\t\t\t}, async (progress) => {\n\t\t\t\tprogress.report({ increment: 20, message: \"Analyzing prompt structure...\" });\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 300));\n\t\t\t\t\n\t\t\t\tprogress.report({ increment: 30, message: \"Enhancing technical details...\" });\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 300));\n\t\t\t\t\n\t\t\t\tprogress.report({ increment: 30, message: \"Finalizing improvements...\" });\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 300));\n\t\t\t\t\n\t\t\t\t// Call our prompt beautifier function\n\t\t\t\treturn await beautifyPromptText(processedPrompt);\n\t\t\t});\n\t\t\t\n\t\t\t// Write the beautified prompt back to clipboard\n\t\t\tawait vscode.env.clipboard.writeText(enhancedPrompt);\n\t\t\t\n\t\t\t// Show agent-like response\n\t\t\tvscode.window.showInformationMessage('@bp agent: Prompt beautified! Press Ctrl+V/Cmd+V to paste.', \n\t\t\t\t{ modal: false, detail: \"The beautified prompt is now in your clipboard\" });\n\t\t} catch (error) {\n\t\t\tvscode.window.showErrorMessage(`@bp agent error: ${error instanceof Error ? error.message : String(error)}`);\n\t\t}\n\t} else {\n\t\tvscode.window.showInformationMessage('@bp agent: Start your prompt with @bp to beautify');\n\t}\n}\n\n/**\n * Generates a sample custom template file in the .github folder\n */\nasync function generateCustomTemplateFile(): Promise<void> {\n\ttry {\n\t\t// Get all workspace folders\n\t\tconst workspaceFolders = vscode.workspace.workspaceFolders;\n\t\tif (!workspaceFolders || workspaceFolders.length === 0) {\n\t\t\tvscode.window.showErrorMessage('No workspace folder found. Please open a folder first.');\n\t\t\treturn;\n\t\t}\n\n\t\t// Use the first workspace folder\n\t\tconst folder = workspaceFolders[0];\n\t\t\n\t\t// Create .github folder if it doesn't exist\n\t\tconst githubFolderUri = vscode.Uri.joinPath(folder.uri, '.github');\n\t\ttry {\n\t\t\tawait vscode.workspace.fs.createDirectory(githubFolderUri);\n\t\t} catch (err) {\n\t\t\tlogDebug('Error creating .github directory (might already exist)', err);\n\t\t\t// Continue anyway - the folder might already exist\n\t\t}\n\t\t\n\t\t// Path for the template file\n\t\tconst templateUri = vscode.Uri.joinPath(githubFolderUri, 'bp_actionA.md');\n\t\t\n\t\t// Sample template content\n\t\tconst templateContent = `<!-- Custom Prompt Template for Beautify Prompt Extension -->\n<!-- The {{PROMPT}} placeholder will be replaced with the original prompt text -->\n\nI want you to transform this prompt into a perfectly structured and detailed prompt for coding:\n\nOriginal Request: \"{{PROMPT}}\"\n\nPlease enhance this request by:\n1. Adding specific programming language and framework details\n2. Breaking down the task into logical steps\n3. Specifying any necessary APIs, libraries, or dependencies\n4. Including performance considerations and edge cases\n5. Adding formatting and style preferences\n6. Requesting code comments and documentation\n7. Defining expected input/output formats\n8. Adding any necessary error handling requirements\n\nThe output should be a comprehensive prompt that will yield high-quality, well-structured, and thoroughly documented code. Focus on making the prompt precise and actionable.`;\n\n\t\t// Check if the file already exists\n\t\ttry {\n\t\t\tawait vscode.workspace.fs.stat(templateUri);\n\t\t\t// File exists, ask for confirmation before overwriting\n\t\t\tconst answer = await vscode.window.showWarningMessage(\n\t\t\t\t'A custom template file already exists. Do you want to replace it?', \n\t\t\t\t{ modal: true },\n\t\t\t\t'Yes', 'No'\n\t\t\t);\n\t\t\t\n\t\t\tif (answer !== 'Yes') {\n\t\t\t\tvscode.window.showInformationMessage('Template generation cancelled.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// File doesn't exist, continue with creation\n\t\t}\n\t\t\n\t\t// Write the template file\n\t\tawait vscode.workspace.fs.writeFile(templateUri, Buffer.from(templateContent, 'utf8'));\n\t\t\n\t\t// Success message\n\t\tvscode.window.showInformationMessage(\n\t\t\t'Custom prompt template created successfully!', \n\t\t\t{ detail: `Template file created at ${templateUri.fsPath}` }\n\t\t);\n\t\t\n\t\t// Open the template file in the editor\n\t\tconst document = await vscode.workspace.openTextDocument(templateUri);\n\t\tawait vscode.window.showTextDocument(document);\n\t\t\n\t} catch (error) {\n\t\tlogDebug('Error creating template file', error);\n\t\tvscode.window.showErrorMessage(`Failed to create template file: ${error instanceof Error ? error.message : String(error)}`);\n\t}\n}\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","logDebug","bpAgentStatusBarItem","vscode","window","createStatusBarItem","StatusBarAlignment","Right","text","tooltip","command","subscriptions","push","beautifyEditorPrompt","commands","registerCommand","async","editor","activeTextEditor","showInformationMessage","selection","isEmpty","originalPrompt","document","getText","hasPrefix","processedPrompt","checkAndProcessAutoBeautifyPrefix","enhancedPrompt","withProgress","location","ProgressLocation","Notification","title","cancellable","progress","beautifyPromptText","edit","editBuilder","replace","error","showErrorMessage","Error","message","String","handleEditorPromptBeautification","beautifyChatPrompt","executeCommand","clipboardText","env","clipboard","readText","trim","writeText","handleChatPromptBeautification","autoBeautifyPrompt","modal","console","checkClipboardForAutoBeautify","bpAgentBeautify","substring","lowerCasePrompt","toLowerCase","bpAgentPrefix","startsWith","log","report","increment","Promise","resolve","setTimeout","detail","handleBpAgentBeautification","generateTemplateCommand","workspaceFolders","workspace","length","folder","githubFolderUri","Uri","joinPath","uri","fs","createDirectory","err","templateUri","templateContent","stat","showWarningMessage","writeFile","Buffer","from","fsPath","openTextDocument","showTextDocument","generateCustomTemplateFile","clipboardCheckInterval","setInterval","statusBarItem","lastClipboardText","hide","show","checkClipboardForBpAgent","dispose","clearInterval","outputChannel","createOutputChannel","data","timestamp","Date","toISOString","appendLine","JSON","stringify","customTemplate","customPromptPath","fileContent","readFile","templateText","toString","name","readCustomPromptTemplate","beautifiedPromptRequest","join","beautifiedPrompt","improvedPrompt","includes","split","simulateCopilotBeautification","promptText","config","getConfiguration","enableAutoBeautify","get","autoBeautifyPrefix","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}