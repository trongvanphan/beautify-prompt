{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://beautify-prompt/./src/extension.ts","webpack://beautify-prompt/external commonjs \"vscode\"","webpack://beautify-prompt/webpack/bootstrap","webpack://beautify-prompt/webpack/startup"],"sourcesContent":["// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\n\n// This method is called when your extension is activated\n// Your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n\t// Use the console to output diagnostic information (console.log) and errors (console.error)\n\tconsole.log('Extension \"beautify-prompt\" is now active');\n\n\t// Register the beautifyPrompt command for editor text\n\tconst beautifyEditorPrompt = vscode.commands.registerCommand('beautify-prompt.beautifyPrompt', async () => {\n\t\tawait handleEditorPromptBeautification();\n\t});\n\n\t// Register the beautifyChatPrompt command for Copilot Chat\n\tconst beautifyChatPrompt = vscode.commands.registerCommand('beautify-prompt.beautifyChatPrompt', async () => {\n\t\tawait handleChatPromptBeautification();\n\t});\n\t\n\t// Register the command to check for and auto-beautify prompts with the prefix\n\tconst autoBeautifyPrompt = vscode.commands.registerCommand('beautify-prompt.checkAutoBeautify', async () => {\n\t\tawait checkClipboardForAutoBeautify();\n\t});\n\n\tcontext.subscriptions.push(beautifyEditorPrompt);\n\tcontext.subscriptions.push(beautifyChatPrompt);\n\tcontext.subscriptions.push(autoBeautifyPrompt);\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}\n\n/**\n * Handles the beautification of prompts in the editor\n */\nasync function handleEditorPromptBeautification(): Promise<void> {\n\tconst editor = vscode.window.activeTextEditor;\n\t\n\tif (!editor) {\n\t\tvscode.window.showInformationMessage('No editor is active');\n\t\treturn;\n\t}\n\n\t// Get the selected text\n\tconst selection = editor.selection;\n\tif (selection.isEmpty) {\n\t\tvscode.window.showInformationMessage('Please select text to beautify');\n\t\treturn;\n\t}\n\t\n\tconst originalPrompt = editor.document.getText(selection);\n\t\n\t// Check if the prompt has the auto-beautify prefix\n\tconst { hasPrefix, processedPrompt } = checkAndProcessAutoBeautifyPrefix(originalPrompt);\n\t\n\ttry {\n\t\t// Show a progress notification\n\t\tconst enhancedPrompt = await vscode.window.withProgress({\n\t\t\tlocation: vscode.ProgressLocation.Notification,\n\t\t\ttitle: \"Beautify prompt...\",\n\t\t\tcancellable: false\n\t\t}, async (progress) => {\n\t\t\t// Call our prompt beautifier function\n\t\t\treturn await beautifyPromptText(processedPrompt);\n\t\t});\n\t\t\n\t\t// Replace the selected text with the beautified prompt\n\t\teditor.edit(editBuilder => {\n\t\t\teditBuilder.replace(selection, enhancedPrompt);\n\t\t});\n\t\t\n\t\tvscode.window.showInformationMessage('Prompt beautified successfully!');\n\t} catch (error) {\n\t\tvscode.window.showErrorMessage(`Failed to beautify prompt: ${error instanceof Error ? error.message : String(error)}`);\n\t}\n}\n\n/**\n * Handles the beautification of prompts in GitHub Copilot Chat\n */\nasync function handleChatPromptBeautification(): Promise<void> {\n\t// Try to find the Copilot Chat input box\n\t// Note: Since there's no public API for Copilot Chat yet, we'll use clipboard as an intermediate\n\t\n\t// Simulate the keyboard shortcut sequence to select all text in the chat input\n\tawait vscode.commands.executeCommand('editor.action.clipboardCopyWithSyntaxHighlightingAction');\n\t\n\t// Get the clipboard content\n\tconst clipboardText = await vscode.env.clipboard.readText();\n\t\n\tif (!clipboardText || clipboardText.trim() === '') {\n\t\tvscode.window.showInformationMessage('No text found in the Copilot Chat input');\n\t\treturn;\n\t}\n\t\n\t// Check if the prompt has the auto-beautify prefix\n\tconst { hasPrefix, processedPrompt } = checkAndProcessAutoBeautifyPrefix(clipboardText);\n\t\n\ttry {\n\t\t// Show a progress notification\n\t\tconst enhancedPrompt = await vscode.window.withProgress({\n\t\t\tlocation: vscode.ProgressLocation.Notification,\n\t\t\ttitle: \"Beautify Copilot Chat prompt...\",\n\t\t\tcancellable: false\n\t\t}, async (progress) => {\n\t\t\t// Call our prompt beautifier function\n\t\t\treturn await beautifyPromptText(processedPrompt);\n\t\t});\n\t\t\n\t\t// Write the beautified prompt back to clipboard\n\t\tawait vscode.env.clipboard.writeText(enhancedPrompt);\n\t\t\n\t\t// Show instructions for pasting\n\t\tvscode.window.showInformationMessage('Prompt beautified! Press Ctrl+V/Cmd+V to paste it into the chat input.');\n\t} catch (error) {\n\t\tvscode.window.showErrorMessage(`Failed to beautify prompt: ${error instanceof Error ? error.message : String(error)}`);\n\t}\n}\n\n/**\n * Beautifies a GitHub Copilot prompt to make it more effective\n * @param originalPrompt The original user prompt text\n * @returns Beautified prompt text\n */\nasync function beautifyPromptText(originalPrompt: string): Promise<string> {\n\t// Creating a beautified version of the prompt\n\tconst promptParts = [\n\t\t// Start with a clear definition of what we're beautifying\n\t\t\"I need to improve this prompt for GitHub Copilot to generate better code in a software development context:\",\n\t\t`Original prompt: \"${originalPrompt}\"`,\n\t\t\n\t\t// Add beautifier instructions specific to software development\n\t\t\"Please beautify this prompt for optimal code generation by:\",\n\t\t\"1. Making it more specific and clearer with precise programming terminology\",\n\t\t\"2. Adding necessary technical context (language, framework, libraries, versions)\",\n\t\t\"3. Indicating expected output format (function signature, class structure, code style)\",\n\t\t\"4. Breaking it into logical development steps or components\",\n\t\t\"5. Specifying error handling, edge cases, and performance considerations\",\n\t\t\"6. Including any necessary imports, dependencies, or setup requirements\",\n\t\t\"7. Mentioning testing expectations if applicable\",\n\t\t\"8. Providing clarity on design patterns or architectural approaches\",\n\t\t\"9. Defining variable naming conventions or code style preferences\",\n\t\t\n\t\t// Request format\n\t\t\"Return only the beautified prompt text without explanations or additional text. Focus exclusively on software development context.\"\n\t];\n\t\n\t// Construct prompt for language model\n\tconst beautifiedPromptRequest = promptParts.join(\"\\n\\n\");\n\t\n\ttry {\n\t\t// Here we would ideally call the GitHub Copilot API directly\n\t\t// Since there's no direct API for prompt beautification, we're implementing a local beautifier\n\t\t\n\t\t// For now, we'll implement a simple beautification logic\n\t\t// In a production extension, you might want to use a proper AI service API\n\t\t\n\t\tconst beautifiedPrompt = await simulateCopilotBeautification(beautifiedPromptRequest);\n\t\treturn beautifiedPrompt;\n\t} catch (error) {\n\t\tconsole.error('Error beautifying prompt:', error);\n\t\tthrow new Error('Failed to beautify prompt. Please try again.');\n\t}\n}\n\n/**\n * Simulates GitHub Copilot's prompt beautification\n * In a real extension, this could be replaced with a call to an actual API\n */\nasync function simulateCopilotBeautification(originalPrompt: string): Promise<string> {\n\t// Software development-specific enhancements\n\tconst improvedPrompt = originalPrompt.trim();\n\t\n\t// Add task structure if not present\n\tlet enhancedPrompt = improvedPrompt;\n\t\n\tif (!improvedPrompt.includes('Task:') && !improvedPrompt.includes('Goal:')) {\n\t\tenhancedPrompt = `Task: ${improvedPrompt}`;\n\t}\n\t\n\t// Add technical context section if missing\n\tif (!improvedPrompt.includes('Context:') && !improvedPrompt.includes('Technology:')) {\n\t\tenhancedPrompt += '\\n\\nContext: Using the latest version of JavaScript/TypeScript with modern ES features.';\n\t}\n\t\n\t// Add language/framework specific details if not mentioned\n\tif (!improvedPrompt.toLowerCase().includes('javascript') && \n\t\t!improvedPrompt.toLowerCase().includes('typescript') && \n\t\t!improvedPrompt.toLowerCase().includes('python') && \n\t\t!improvedPrompt.toLowerCase().includes('java') && \n\t\t!improvedPrompt.toLowerCase().includes('c#')) {\n\t\tenhancedPrompt += '\\n\\nLanguage: Implement this in TypeScript with strict type checking.';\n\t}\n\t\n\t// Add expected output format if missing\n\tif (!improvedPrompt.includes('Expected output:') && \n\t\t!improvedPrompt.includes('Return:') &&\n\t\t!improvedPrompt.includes('Output:')) {\n\t\tenhancedPrompt += '\\n\\nExpected output: Well-structured, documented code with proper types and error handling.';\n\t}\n\t\n\t// Add requirements section if not present\n\tif (!improvedPrompt.includes('Requirements:')) {\n\t\tenhancedPrompt += '\\n\\nRequirements:';\n\t\tenhancedPrompt += '\\n1. Code should be maintainable and follow SOLID principles';\n\t\tenhancedPrompt += '\\n2. Include proper error handling for edge cases';\n\t\tenhancedPrompt += '\\n3. Optimize for performance where applicable';\n\t\tenhancedPrompt += '\\n4. Add comprehensive documentation';\n\t}\n\t\n\t// Add testing expectations if not mentioned\n\tif (!improvedPrompt.includes('Testing:') && !improvedPrompt.includes('tests')) {\n\t\tenhancedPrompt += '\\n\\nTesting: Include examples of how to test the code.';\n\t}\n\t\n\t// Add specificity if the prompt is very short\n\tif (improvedPrompt.split(' ').length < 5) {\n\t\tenhancedPrompt += '\\n\\nPlease provide a comprehensive solution with proper architecture, error handling, and documentation comments.';\n\t}\n\t\n\t// Simulate API call delay\n\tawait new Promise(resolve => setTimeout(resolve, 1000));\n\t\n\treturn enhancedPrompt;\n}\n\n/**\n * Checks if a prompt starts with the auto-beautify prefix and processes it accordingly\n * @param promptText The original prompt text\n * @returns Object containing whether the prefix was found and the processed prompt\n */\nfunction checkAndProcessAutoBeautifyPrefix(promptText: string): { hasPrefix: boolean; processedPrompt: string } {\n\t// Get the configuration\n\tconst config = vscode.workspace.getConfiguration('beautify-prompt');\n\tconst enableAutoBeautify = config.get<boolean>('enableAutoBeautify', true);\n\tconst autoBeautifyPrefix = config.get<string>('autoBeautifyPrefix', 'beautify prompt:').toLowerCase();\n\t\n\t// If auto-beautify is disabled, return the original prompt\n\tif (!enableAutoBeautify) {\n\t\treturn { hasPrefix: false, processedPrompt: promptText };\n\t}\n\t\n\t// Check if the prompt starts with the prefix (case insensitive)\n\tconst lowerCasePrompt = promptText.toLowerCase();\n\tif (lowerCasePrompt.startsWith(autoBeautifyPrefix)) {\n\t\t// Remove the prefix from the prompt (use the original case)\n\t\tconst processedPrompt = promptText.substring(autoBeautifyPrefix.length).trim();\n\t\treturn { hasPrefix: true, processedPrompt };\n\t}\n\t\n\t// Return the original prompt if no prefix is found\n\treturn { hasPrefix: false, processedPrompt: promptText };\n}\n\n/**\n * Checks the clipboard content for the auto-beautify prefix and beautifies it if found\n * This can be used to auto-beautify prompts as they're being typed\n */\nasync function checkClipboardForAutoBeautify(): Promise<void> {\n\t// Get the clipboard content\n\tconst clipboardText = await vscode.env.clipboard.readText();\n\t\n\tif (!clipboardText || clipboardText.trim() === '') {\n\t\treturn;\n\t}\n\t\n\t// Check if the prompt has the auto-beautify prefix\n\tconst { hasPrefix, processedPrompt } = checkAndProcessAutoBeautifyPrefix(clipboardText);\n\t\n\t// Only proceed if the prefix is found\n\tif (hasPrefix) {\n\t\ttry {\n\t\t\t// Beautify the prompt\n\t\t\tconst enhancedPrompt = await beautifyPromptText(processedPrompt);\n\t\t\t\n\t\t\t// Write the beautified prompt back to clipboard\n\t\t\tawait vscode.env.clipboard.writeText(enhancedPrompt);\n\t\t\t\n\t\t\t// Show a subtle notification\n\t\t\tvscode.window.showInformationMessage('Auto-beautified prompt!', { modal: false });\n\t\t} catch (error) {\n\t\t\tconsole.error('Error during auto-beautification:', error);\n\t\t}\n\t}\n}\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","console","log","beautifyEditorPrompt","vscode","commands","registerCommand","async","editor","window","activeTextEditor","showInformationMessage","selection","isEmpty","originalPrompt","document","getText","hasPrefix","processedPrompt","checkAndProcessAutoBeautifyPrefix","enhancedPrompt","withProgress","location","ProgressLocation","Notification","title","cancellable","progress","beautifyPromptText","edit","editBuilder","replace","error","showErrorMessage","Error","message","String","handleEditorPromptBeautification","beautifyChatPrompt","executeCommand","clipboardText","env","clipboard","readText","trim","writeText","handleChatPromptBeautification","autoBeautifyPrompt","modal","checkClipboardForAutoBeautify","subscriptions","push","beautifiedPromptRequest","join","beautifiedPrompt","improvedPrompt","includes","toLowerCase","split","length","Promise","resolve","setTimeout","simulateCopilotBeautification","promptText","config","workspace","getConfiguration","enableAutoBeautify","get","autoBeautifyPrefix","startsWith","substring","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}